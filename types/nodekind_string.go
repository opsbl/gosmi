// Code generated by "enumer -type=NodeKind -trimprefix=NodeKind -json -yaml -output=nodekind_string.go"; DO NOT EDIT.

package types

import (
	"encoding/json"
	"fmt"
	"strings"
)

const (
	_NodeKindName_0      = "NodeUnknownNodeNodeNodeScalar"
	_NodeKindLowerName_0 = "nodeunknownnodenodenodescalar"
	_NodeKindName_1      = "NodeTable"
	_NodeKindLowerName_1 = "nodetable"
	_NodeKindName_2      = "NodeRow"
	_NodeKindLowerName_2 = "noderow"
	_NodeKindName_3      = "NodeColumn"
	_NodeKindLowerName_3 = "nodecolumn"
	_NodeKindName_4      = "NodeNotification"
	_NodeKindLowerName_4 = "nodenotification"
	_NodeKindName_5      = "NodeGroup"
	_NodeKindLowerName_5 = "nodegroup"
	_NodeKindName_6      = "NodeCompliance"
	_NodeKindLowerName_6 = "nodecompliance"
	_NodeKindName_7      = "NodeCapabilities"
	_NodeKindLowerName_7 = "nodecapabilities"
	_NodeKindName_8      = "NodeAny"
	_NodeKindLowerName_8 = "nodeany"
)

var (
	_NodeKindIndex_0 = [...]uint8{0, 11, 19, 29}
	_NodeKindIndex_1 = [...]uint8{0, 9}
	_NodeKindIndex_2 = [...]uint8{0, 7}
	_NodeKindIndex_3 = [...]uint8{0, 10}
	_NodeKindIndex_4 = [...]uint8{0, 16}
	_NodeKindIndex_5 = [...]uint8{0, 9}
	_NodeKindIndex_6 = [...]uint8{0, 14}
	_NodeKindIndex_7 = [...]uint8{0, 16}
	_NodeKindIndex_8 = [...]uint8{0, 7}
)

func (i NodeKind) String() string {
	switch {
	case 0 <= i && i <= 2:
		return _NodeKindName_0[_NodeKindIndex_0[i]:_NodeKindIndex_0[i+1]]
	case i == 4:
		return _NodeKindName_1
	case i == 8:
		return _NodeKindName_2
	case i == 16:
		return _NodeKindName_3
	case i == 32:
		return _NodeKindName_4
	case i == 64:
		return _NodeKindName_5
	case i == 128:
		return _NodeKindName_6
	case i == 256:
		return _NodeKindName_7
	case i == 65535:
		return _NodeKindName_8
	default:
		return fmt.Sprintf("NodeKind(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NodeKindNoOp() {
	var x [1]struct{}
	_ = x[NodeUnknown-(0)]
	_ = x[NodeNode-(1)]
	_ = x[NodeScalar-(2)]
	_ = x[NodeTable-(4)]
	_ = x[NodeRow-(8)]
	_ = x[NodeColumn-(16)]
	_ = x[NodeNotification-(32)]
	_ = x[NodeGroup-(64)]
	_ = x[NodeCompliance-(128)]
	_ = x[NodeCapabilities-(256)]
	_ = x[NodeAny-(65535)]
}

var _NodeKindValues = []NodeKind{NodeUnknown, NodeNode, NodeScalar, NodeTable, NodeRow, NodeColumn, NodeNotification, NodeGroup, NodeCompliance, NodeCapabilities, NodeAny}

var _NodeKindNameToValueMap = map[string]NodeKind{
	_NodeKindName_0[0:11]:       NodeUnknown,
	_NodeKindLowerName_0[0:11]:  NodeUnknown,
	_NodeKindName_0[11:19]:      NodeNode,
	_NodeKindLowerName_0[11:19]: NodeNode,
	_NodeKindName_0[19:29]:      NodeScalar,
	_NodeKindLowerName_0[19:29]: NodeScalar,
	_NodeKindName_1[0:9]:        NodeTable,
	_NodeKindLowerName_1[0:9]:   NodeTable,
	_NodeKindName_2[0:7]:        NodeRow,
	_NodeKindLowerName_2[0:7]:   NodeRow,
	_NodeKindName_3[0:10]:       NodeColumn,
	_NodeKindLowerName_3[0:10]:  NodeColumn,
	_NodeKindName_4[0:16]:       NodeNotification,
	_NodeKindLowerName_4[0:16]:  NodeNotification,
	_NodeKindName_5[0:9]:        NodeGroup,
	_NodeKindLowerName_5[0:9]:   NodeGroup,
	_NodeKindName_6[0:14]:       NodeCompliance,
	_NodeKindLowerName_6[0:14]:  NodeCompliance,
	_NodeKindName_7[0:16]:       NodeCapabilities,
	_NodeKindLowerName_7[0:16]:  NodeCapabilities,
	_NodeKindName_8[0:7]:        NodeAny,
	_NodeKindLowerName_8[0:7]:   NodeAny,
}

var _NodeKindNames = []string{
	_NodeKindName_0[0:11],
	_NodeKindName_0[11:19],
	_NodeKindName_0[19:29],
	_NodeKindName_1[0:9],
	_NodeKindName_2[0:7],
	_NodeKindName_3[0:10],
	_NodeKindName_4[0:16],
	_NodeKindName_5[0:9],
	_NodeKindName_6[0:14],
	_NodeKindName_7[0:16],
	_NodeKindName_8[0:7],
}

// NodeKindString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NodeKindString(s string) (NodeKind, error) {
	if val, ok := _NodeKindNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NodeKindNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to NodeKind values", s)
}

// NodeKindValues returns all values of the enum
func NodeKindValues() []NodeKind {
	return _NodeKindValues
}

// NodeKindStrings returns a slice of all String values of the enum
func NodeKindStrings() []string {
	strs := make([]string, len(_NodeKindNames))
	copy(strs, _NodeKindNames)
	return strs
}

// IsANodeKind returns "true" if the value is listed in the enum definition. "false" otherwise
func (i NodeKind) IsANodeKind() bool {
	for _, v := range _NodeKindValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for NodeKind
func (i NodeKind) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for NodeKind
func (i *NodeKind) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("NodeKind should be a string, got %s", data)
	}

	var err error
	*i, err = NodeKindString(s)
	return err
}

// MarshalYAML implements a YAML Marshaler for NodeKind
func (i NodeKind) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for NodeKind
func (i *NodeKind) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = NodeKindString(s)
	return err
}
